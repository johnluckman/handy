/**
 * RESTOCK PRODUCT SYNC - POPULATE RESTOCK TABLES FOR BOTH LOCATIONS
 * ================================================================
 * 
 * This script populates both restock_newtown and restock_paddington Supabase databases 
 * with product data from the products database, creating the foundation for restocking workflows.
 * 
 * USAGE EXAMPLES
 * --------------
 * 
 * # Populate both restock tables with all active products
 * node scripts/restockProductSync.js
 * 
 * # Populate only Newtown table
 * node scripts/restockProductSync.js --location=newtown
 * 
 * # Populate only Paddington table  
 * node scripts/restockProductSync.js --location=paddington
 * 
 * # Populate with specific product statuses
 * node scripts/restockProductSync.js --status "Active,Primary"
 * 
 * # Test mode - only process first 10 products
 * node scripts/restockProductSync.js --test
 * 
 * # Clear existing data before populating
 * node scripts/restockProductSync.js --clear
 * 
 * # Dry run - show what would be inserted without actually inserting
 * node scripts/restockProductSync.js --dry-run
 * 
 * COMMAND LINE OPTIONS
 * -------------------- 
 * --location=LOCATION  Specific location to sync (newtown, paddington, or both)
 * --status=LIST        Comma-separated list of product statuses to include
 * --test               Test mode - only process first 10 items
 * --clear              Clear existing restock data before populating
 * --dry-run            Show what would be inserted without actually inserting
 * --help, -h           Show usage information
 * 
 * WHAT THIS SCRIPT DOES
 * ---------------------
 * 1. Fetches products from the products table in Supabase
 * 2. Filters by active status (Active, Primary by default)
 * 3. Creates restock records in restock_newtown and/or restock_paddington tables
 * 4. Maps: id, product_id, option_product_id, productOptionCode, name, option1, option2, option3
 * 5. Initializes all quantity fields to 0
 * 6. Sets last_updated timestamp
 * 
 * @author Generated by AI Assistant
 * @version 2.0
 * @date 2025-01-24
 */

import 'dotenv/config';
import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL = process.env.EXPO_PUBLIC_SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY;

// Validate environment variables
if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  console.error('Missing required environment variables:');
  console.error('SUPABASE_URL:', SUPABASE_URL ? 'Set' : 'NOT SET');
  console.error('SUPABASE_ANON_KEY:', SUPABASE_ANON_KEY ? 'Set' : 'NOT SET');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Parse command line arguments
const args = process.argv.slice(2);
const options = {
  location: 'both', // 'newtown', 'paddington', or 'both'
  status: 'Active,Primary',
  test: false,
  clear: false,
  dryRun: false,
  help: false
};

// Parse command line arguments
args.forEach(arg => {
  if (arg === '--help' || arg === '-h') {
    options.help = true;
  } else if (arg === '--test') {
    options.test = true;
  } else if (arg === '--clear') {
    options.clear = true;
  } else if (arg === '--dry-run') {
    options.dryRun = true;
  } else if (arg.startsWith('--location=')) {
    const location = arg.split('=')[1].toLowerCase();
    if (['newtown', 'paddington', 'both'].includes(location)) {
      options.location = location;
    } else {
      console.error('Invalid location. Must be: newtown, paddington, or both');
      process.exit(1);
    }
  } else if (arg.startsWith('--status=')) {
    options.status = arg.split('=')[1];
  }
});

if (options.help) {
  console.log(`
RESTOCK PRODUCT SYNC - POPULATE RESTOCK TABLES FOR BOTH LOCATIONS
================================================================

This script populates both restock_newtown and restock_paddington Supabase databases 
with product data from the products database.

USAGE:
  node scripts/restockProductSync.js [OPTIONS]

OPTIONS:
  --location=LOCATION  Specific location to sync (newtown, paddington, or both)
  --status=LIST        Comma-separated list of product statuses (default: "Active,Primary")
  --test               Test mode - only process first 10 items
  --clear              Clear existing restock data before populating
  --dry-run            Show what would be inserted without actually inserting
  --help, -h           Show this help message

EXAMPLES:
  # Populate both locations
  node scripts/restockProductSync.js

  # Populate only Newtown
  node scripts/restockProductSync.js --location=newtown

  # Populate only Paddington
  node scripts/restockProductSync.js --location=paddington

  # Test mode with specific location
  node scripts/restockProductSync.js --location=newtown --test

  # Clear and repopulate both
  node scripts/restockProductSync.js --clear
`);
  process.exit(0);
}

// Progress tracking
let processedCount = 0;
let successCount = 0;
let errorCount = 0;
let skippedCount = 0;

function logProgress(message, type = 'info') {
  const timestamp = new Date().toISOString();
  const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
  console.log(`[${timestamp}] ${prefix} ${message}`);
}

async function clearRestockTable(tableName) {
  if (!options.clear) return;
  
  logProgress(`Clearing existing ${tableName} data...`);
  
  try {
    const { error } = await supabase
      .from(tableName)
      .delete()
      .neq('id', 0); // Delete all records
    
    if (error) {
      throw error;
    }
    
    logProgress(`${tableName} table cleared successfully`, 'success');
  } catch (error) {
    logProgress(`Failed to clear ${tableName} table: ${error.message}`, 'error');
    throw error;
  }
}

async function fetchProducts() {
  const statuses = options.status.split(',').map(s => s.trim());
  
  logProgress(`Fetching products with status: ${statuses.join(', ')}`);
  
  try {
    let allProducts = [];
    let page = 0;
    const pageSize = 1000; // Supabase max page size
    let hasMore = true;
    
    while (hasMore) {
      const offset = page * pageSize;
      
      let query = supabase
        .from('products')
        .select('id, option_id, option_productId, code, option_status, "productOptionCode", name, option1, option2, option3')
        .in('option_status', statuses)
        .range(offset, offset + pageSize - 1);
      
      if (options.test && page === 0) {
        query = query.limit(10);
        logProgress('TEST MODE: Limiting to 10 products');
      }
      
      const { data: products, error } = await query;
      
      if (error) {
        throw error;
      }
      
      if (!products || products.length === 0) {
        hasMore = false;
        break;
      }
      
      allProducts.push(...products);
      logProgress(`Fetched page ${page + 1}: ${products.length} products (total so far: ${allProducts.length})`);
      
      // If we got less than pageSize, we've reached the end
      if (products.length < pageSize) {
        hasMore = false;
      }
      
      page++;
      
      // Small delay between pages to avoid overwhelming the API
      if (hasMore) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    logProgress(`Found ${allProducts.length} total products to process`, 'success');
    return allProducts;
    
  } catch (error) {
    logProgress(`Failed to fetch products: ${error.message}`, 'error');
    throw error;
  }
}

async function createRestockRecords(products, tableName) {
  logProgress(`Creating restock records for ${tableName}...`);
  
  const restockRecords = products.map(product => ({
    product_id: product.id,
    option_product_id: product.option_id || product.option_productId || product.id,
    "productOptionCode": product.productOptionCode || product.code,
    name: product.name,
    option1: product.option1,
    option2: product.option2,
    option3: product.option3,
    sold: 0,
    returned: 0,
    picked: 0,
    review: 0,
    storeroom_empty: 0,
    missing: 0,
    last_updated: new Date().toISOString()
  }));
  
  if (options.dryRun) {
    logProgress(`DRY RUN MODE: Would insert ${restockRecords.length} records into ${tableName}`);
    restockRecords.slice(0, 3).forEach((record, index) => {
      console.log(`  ${index + 1}. ${record.name} (${record.productOptionCode})`);
    });
    if (restockRecords.length > 3) {
      console.log(`  ... and ${restockRecords.length - 3} more records`);
    }
    return { count: restockRecords.length };
  }
  
  try {
    // Insert in batches to avoid overwhelming the database
    const batchSize = 100;
    const batches = [];
    
    for (let i = 0; i < restockRecords.length; i += batchSize) {
      batches.push(restockRecords.slice(i, i + batchSize));
    }
    
    logProgress(`Inserting ${restockRecords.length} records into ${tableName} in ${batches.length} batches...`);
    
    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      const { error } = await supabase
        .from(tableName)
        .insert(batch);
      
      if (error) {
        throw error;
      }
      
      processedCount += batch.length;
      logProgress(`Batch ${i + 1}/${batches.length} completed for ${tableName} (${processedCount}/${restockRecords.length} total)`);
      
      // Small delay between batches
      if (i < batches.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    logProgress(`Successfully created ${restockRecords.length} restock records in ${tableName}`, 'success');
    return { count: restockRecords.length };
    
  } catch (error) {
    logProgress(`Failed to create restock records in ${tableName}: ${error.message}`, 'error');
    throw error;
  }
}

async function validateRestockTable(tableName) {
  logProgress(`Validating ${tableName} table structure...`);
  
  try {
    // Check if table exists and has correct structure
    const { data: columns, error } = await supabase
      .from(tableName)
      .select('*')
      .limit(1);
    
    if (error) {
      throw error;
    }
    
    logProgress(`${tableName} table structure validated`, 'success');
    return true;
    
  } catch (error) {
    logProgress(`${tableName} table validation failed: ${error.message}`, 'error');
    logProgress(`Make sure the ${tableName} table exists with the correct structure`, 'warning');
    return false;
  }
}

async function syncLocation(location) {
  const tableName = `restock_${location}`;
  
  logProgress(`ðŸ”„ Starting sync for ${location}...`);
  
  // Validate table structure
  const isValid = await validateRestockTable(tableName);
  if (!isValid) {
    throw new Error(`${tableName} table validation failed`);
  }
  
  // Clear table if requested
  if (options.clear) {
    await clearRestockTable(tableName);
  }
  
  // Fetch products
  const products = await fetchProducts();
  
  if (products.length === 0) {
    logProgress(`No products found to process for ${location}`, 'warning');
    return { count: 0 };
  }
  
  // Create restock records
  const result = await createRestockRecords(products, tableName);
  
  logProgress(`âœ… ${location} sync completed: ${result.count} records created`, 'success');
  return result;
}

async function main() {
  const startTime = Date.now();
  
  try {
    logProgress('ðŸš€ Starting Restock Product Sync...');
    logProgress(`Options: ${JSON.stringify(options, null, 2)}`);
    
    let results = {};
    
    if (options.location === 'both' || options.location === 'newtown') {
      results.newtown = await syncLocation('newtown');
    }
    
    if (options.location === 'both' || options.location === 'paddington') {
      results.paddington = await syncLocation('paddington');
    }
    
    const endTime = Date.now();
    const duration = ((endTime - startTime) / 1000).toFixed(2);
    
    logProgress('ðŸŽ‰ Restock Product Sync completed successfully!', 'success');
    logProgress(`ðŸ“Š Final Summary:`);
    
    if (results.newtown) {
      logProgress(`   â€¢ Newtown: ${results.newtown.count} records`);
    }
    if (results.paddington) {
      logProgress(`   â€¢ Paddington: ${results.paddington.count} records`);
    }
    
    logProgress(`   â€¢ Duration: ${duration} seconds`);
    
    if (options.dryRun) {
      logProgress('âš ï¸  This was a dry run - no actual data was inserted');
    }
    
  } catch (error) {
    logProgress(`ðŸ’¥ Restock Product Sync failed: ${error.message}`, 'error');
    console.error('Full error:', error);
    process.exit(1);
  }
}

// Handle process termination gracefully
process.on('SIGINT', () => {
  logProgress('Received SIGINT, shutting down gracefully...', 'warning');
  process.exit(0);
});

process.on('SIGTERM', () => {
  logProgress('Received SIGTERM, shutting down gracefully...', 'warning');
  process.exit(0);
});

// Run the main function
main().catch(error => {
  logProgress(`Unhandled error: ${error.message}`, 'error');
  process.exit(1);
});
